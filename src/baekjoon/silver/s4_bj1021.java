package baekjoon.silver;
/*문제 : 회전하는 큐*/
/*미해결*/

/*문제 이해
* N개의 원소를 포함하는 양방향 순환 큐
* 이 큐에서 몇 개의 원소를 뽑을 것이다.
* 큐에는 3가지 연산을 한다.
* 1. 첫번째 원소를 뽑기
* 2. 왼쪽으로 한칸 이동시키기
* 3. 오른쪽으로 한칸 이동시키기
* 원소의 위치가 주어진다 - 최소 큐에서의 위치임
* 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램이다.
* 첫째줄에 큐의 크기 N과 뽑아내려고하는 수의 개수 M
* 1<N<50, M<=N 자연수,
* 둘째줄 -> 뽑아내려고 하는 위치가 순서대로 주어짐*/

/*접근법
* 1. 3개의 기능을 가진 큐를 만든다.
* 2. N의 개수를 가진 큐를 만든다.
* 3. M을 입력 받아서 3개의 수를 추가로 입력받는다.
* 4. 각각의 인덱스를 뽑아내기 위해서 2,3번의 기능이 사용될 때마다 +1을 해준다.*/

import java.util.ArrayList;

/*1.3개의 기능을 가진 큐를 만든다.*/
//뭐가 필요하지?
//생성자, 정수형 배열,
class Queue<integer>{
    //생성자를 이용해서 N 크기의 배열을 만든다.
    ArrayList<integer> myque;
    Queue(int N){
        myque = new ArrayList<>(N);
    }
    /*1-2. 기능을 만들자*/
    //기능이 뭔데?
    //1. 첫번째 수를 뽑는 기능 -> 하나가 없어지면, 인덱스를 어떻게 밀지?
    public void delete(){
        myque.remove(0);
        //문제 : 배열의  인덱스 0 의 데이터는 지웠는데, 배열의 크기가 작아진 것은 아니다. ??
    }
    //2. 왼쪽으로 이동하는 기능
    public void left(){
        //왼쪽으로 어떻게 움직이지?
        //temp를 이용해서 인덱스 0인 값을 뒤로 옮기자
        int temp = (int) myque.get(0);
        for(int i=0;i<myque.size();i++){
            //arrayLIst를 통해서 배열처럼 다음과 같이 하려면, 어떻게 해야하지?
            //   myque[i]=myque[i+1];
            //문제 : 왜 안되는 걸까? 배열인데, 왜 인덱스를 넣으니까
        }
    }
    //3. 오른쪽으로 이동하는 기능
    public void right(){
        //오른쪽으로 어떻게 움직이지?
    }
}

//막힌 부분 : 큐를 구현 시, 왼쪽 이동과 오른쪽 이동 구현.
//생각하는 부분 : 배열의 값들을 왼쪽으로 옮기는 방법이 있나?

public class s4_bj1021 {
    public static void main(String[] args) {

    }
}
